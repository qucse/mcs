"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _got = _interopRequireDefault(require("got"));

var _sharp = _interopRequireDefault(require("sharp"));

var _lodash = _interopRequireDefault(require("lodash.find"));

var _lodash2 = _interopRequireDefault(require("lodash.uniqby"));

var _url = _interopRequireDefault(require("url"));

var _lodash3 = _interopRequireDefault(require("lodash.chunk"));

var _image = _interopRequireDefault(require("./image"));

var _marker = _interopRequireDefault(require("./marker"));

var _polyline = _interopRequireDefault(require("./polyline"));

var _text = _interopRequireDefault(require("./text"));

var _asyncQueue = _interopRequireDefault(require("./helper/asyncQueue"));

// import process from 'process';
// import pjson from '../package.json';

/* transform longitude to tile number */
var lonToX = function lonToX(lon, zoom) {
  return (lon + 180) / 360 * Math.pow(2, zoom);
};
/* transform latitude to tile number */


var latToY = function latToY(lat, zoom) {
  return (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom);
};

var yToLat = function yToLat(y, zoom) {
  return Math.atan(Math.sinh(Math.PI * (1 - 2 * y / Math.pow(2, zoom)))) / Math.PI * 180;
};

var xToLon = function xToLon(x, zoom) {
  return x / Math.pow(2, zoom) * 360 - 180;
};

var LINE_RENDER_CHUNK_SIZE = 1000;

var StaticMaps = /*#__PURE__*/function () {
  function StaticMaps() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2["default"])(this, StaticMaps);
    this.options = options;
    this.width = this.options.width;
    this.height = this.options.height;
    this.paddingX = this.options.paddingX || 0;
    this.paddingY = this.options.paddingY || 0;
    this.padding = [this.paddingX, this.paddingY];
    this.tileUrl = this.options.tileUrl || 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
    this.tileSize = this.options.tileSize || 256;
    this.tileRequestTimeout = this.options.tileRequestTimeout;
    this.tileRequestHeader = this.options.tileRequestHeader;
    this.tileRequestLimit = this.options.tileRequestLimit || 2;
    this.reverseY = this.options.reverseY || false;
    this.maxZoom = this.options.maxZoom;
    this.zoomRange = this.options.zoomRange || {
      min: 1,
      max: 17
    }; // # features

    this.markers = [];
    this.lines = [];
    this.polygons = [];
    this.text = []; // # fields that get set when map is rendered

    this.center = [];
    this.centerX = 0;
    this.centerY = 0;
    this.zoom = 0;
  }

  (0, _createClass2["default"])(StaticMaps, [{
    key: "addLine",
    value: function addLine(options) {
      this.lines.push(new _polyline["default"](options));
    }
  }, {
    key: "addMarker",
    value: function addMarker(options) {
      this.markers.push(new _marker["default"](options));
    }
  }, {
    key: "addPolygon",
    value: function addPolygon(options) {
      this.lines.push(new _polyline["default"](options));
    }
  }, {
    key: "addText",
    value: function addText(options) {
      this.text.push(new _text["default"](options));
    }
    /**
      * Render static map with all map features that were added to map before
      */

  }, {
    key: "render",
    value: function () {
      var _render = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(center, zoom) {
        var extent, centerLon, centerLat;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(!this.lines && !this.markers && !this.polygons && !(center && zoom))) {
                  _context.next = 2;
                  break;
                }

                throw new Error('Cannot render empty map: Add  center || lines || markers || polygons.');

              case 2:
                this.center = center;
                this.zoom = zoom || this.calculateZoom();

                if (this.maxZoom && this.zoom > this.maxZoom) {
                  this.zoom = this.maxZoom;
                }

                if (center && center.length === 2) {
                  this.centerX = lonToX(center[0], this.zoom);
                  this.centerY = latToY(center[1], this.zoom);
                } else {
                  // # get extent of all lines
                  extent = this.determineExtent(this.zoom); // # calculate center point of map

                  centerLon = (extent[0] + extent[2]) / 2;
                  centerLat = (extent[1] + extent[3]) / 2;
                  this.centerX = lonToX(centerLon, this.zoom);
                  this.centerY = latToY(centerLat, this.zoom);
                }

                this.image = new _image["default"](this.options);
                _context.next = 9;
                return Promise.all([this.drawBaselayer(), this.loadMarker()]);

              case 9:
                return _context.abrupt("return", this.drawFeatures());

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function render(_x, _x2) {
        return _render.apply(this, arguments);
      }

      return render;
    }()
    /**
      * calculate common extent of all current map features
      */

  }, {
    key: "determineExtent",
    value: function determineExtent(zoom) {
      var extents = []; // Add bbox to extent

      if (this.center && this.center.length >= 4) extents.push(this.center); // Add polylines and polygons to extent

      if (this.lines.length) {
        this.lines.forEach(function (line) {
          extents.push(line.extent());
        });
      } // extents.push(this.lines.map(function(line){ return line.extent(); }));
      // Add marker to extent


      for (var i = 0; i < this.markers.length; i++) {
        var marker = this.markers[i];
        var e = [marker.coord[0], marker.coord[1]];

        if (!zoom) {
          extents.push([marker.coord[0], marker.coord[1], marker.coord[0], marker.coord[1]]);
          continue;
        } // # consider dimension of marker


        var ePx = marker.extentPx();
        var x = lonToX(e[0], zoom);
        var y = latToY(e[1], zoom);
        extents.push([xToLon(x - parseFloat(ePx[0]) / this.tileSize, zoom), yToLat(y + parseFloat(ePx[1]) / this.tileSize, zoom), xToLon(x + parseFloat(ePx[2]) / this.tileSize, zoom), yToLat(y - parseFloat(ePx[3]) / this.tileSize, zoom)]);
      }

      return [Math.min.apply(Math, (0, _toConsumableArray2["default"])(extents.map(function (e) {
        return e[0];
      }))), Math.min.apply(Math, (0, _toConsumableArray2["default"])(extents.map(function (e) {
        return e[1];
      }))), Math.max.apply(Math, (0, _toConsumableArray2["default"])(extents.map(function (e) {
        return e[2];
      }))), Math.max.apply(Math, (0, _toConsumableArray2["default"])(extents.map(function (e) {
        return e[3];
      })))];
    }
    /**
      * calculate the best zoom level for given extent
      */

  }, {
    key: "calculateZoom",
    value: function calculateZoom() {
      for (var z = this.zoomRange.max; z >= this.zoomRange.min; z--) {
        var extent = this.determineExtent(z);
        var width = (lonToX(extent[2], z) - lonToX(extent[0], z)) * this.tileSize;
        if (width > this.width - this.padding[0] * 2) continue;
        var height = (latToY(extent[1], z) - latToY(extent[3], z)) * this.tileSize;
        if (height > this.height - this.padding[1] * 2) continue;
        return z;
      }

      return this.zoomRange.min;
    }
    /**
      * transform tile number to pixel on image canvas
      */

  }, {
    key: "xToPx",
    value: function xToPx(x) {
      var px = (x - this.centerX) * this.tileSize + this.width / 2;
      return Number(Math.round(px));
    }
    /**
      * transform tile number to pixel on image canvas
      */

  }, {
    key: "yToPx",
    value: function yToPx(y) {
      var px = (y - this.centerY) * this.tileSize + this.height / 2;
      return Number(Math.round(px));
    }
  }, {
    key: "drawBaselayer",
    value: function () {
      var _drawBaselayer = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        var xMin, yMin, xMax, yMax, result, x, y, maxTile, tileX, tileY, tiles;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                xMin = Math.floor(this.centerX - 0.5 * this.width / this.tileSize);
                yMin = Math.floor(this.centerY - 0.5 * this.height / this.tileSize);
                xMax = Math.ceil(this.centerX + 0.5 * this.width / this.tileSize);
                yMax = Math.ceil(this.centerY + 0.5 * this.height / this.tileSize);
                result = [];

                for (x = xMin; x < xMax; x++) {
                  for (y = yMin; y < yMax; y++) {
                    // # x and y may have crossed the date line
                    maxTile = Math.pow(2, this.zoom);
                    tileX = (x + maxTile) % maxTile;
                    tileY = (y + maxTile) % maxTile;
                    if (this.reverseY) tileY = (1 << this.zoom) - tileY - 1;
                    result.push({
                      url: this.tileUrl.replace('{z}', this.zoom).replace('{x}', tileX).replace('{y}', tileY),
                      box: [this.xToPx(x), this.yToPx(y), this.xToPx(x + 1), this.yToPx(y + 1)]
                    });
                  }
                }

                _context2.next = 8;
                return this.getTiles(result);

              case 8:
                tiles = _context2.sent;
                return _context2.abrupt("return", this.image.draw(tiles.filter(function (v) {
                  return v.success;
                }).map(function (v) {
                  return v.tile;
                })));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function drawBaselayer() {
        return _drawBaselayer.apply(this, arguments);
      }

      return drawBaselayer;
    }()
  }, {
    key: "drawText",
    value: function () {
      var _drawText = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        var _this = this;

        var queue;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (this.text.length) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return", null);

              case 2:
                queue = [];
                this.text.forEach(function (text) {
                  queue.push( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
                    return _regenerator["default"].wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return _this.renderText(text);

                          case 2:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  })));
                });
                return _context4.abrupt("return", (0, _asyncQueue["default"])(queue));

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function drawText() {
        return _drawText.apply(this, arguments);
      }

      return drawText;
    }()
  }, {
    key: "drawFeatures",
    value: function () {
      var _drawFeatures = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.drawLines();

              case 2:
                _context5.next = 4;
                return this.drawMarker();

              case 4:
                _context5.next = 6;
                return this.drawText();

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function drawFeatures() {
        return _drawFeatures.apply(this, arguments);
      }

      return drawFeatures;
    }()
    /**
     * Render text on a baseimage
     */

  }, {
    key: "renderText",
    value: function () {
      var _renderText = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(text) {
        var _this2 = this;

        var baseImage;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                baseImage = (0, _sharp["default"])(this.image.image);
                return _context6.abrupt("return", new Promise(function (resolve, reject) {
                  var mapcoords = [_this2.xToPx(lonToX(text.coord[0], _this2.zoom)), _this2.yToPx(latToY(text.coord[1], _this2.zoom))];
                  baseImage.metadata().then(function (imageMetadata) {
                    var svgPath = "\n            <svg\n              width=\"".concat(imageMetadata.width, "px\"\n              height=\"").concat(imageMetadata.height, "px\"\n              version=\"1.1\"\n              xmlns=\"http://www.w3.org/2000/svg\">\n              <text\n                x=\"").concat(mapcoords[0], "\"\n                y=\"").concat(mapcoords[1], "\"\n                style=\"fill-rule: inherit; font-family: ").concat(text.font, ";\"\n                font-size=\"").concat(text.size, "pt\"\n                stroke=\"").concat(text.color, "\"\n                fill=\"").concat(text.fill ? text.fill : 'none', "\"\n                stroke-width=\"").concat(text.width, "\"\n                text-anchor=\"").concat(text.anchor, "\"\n              >\n                  ").concat(text.text, "</text>\n            </svg>");
                    baseImage.composite([{
                      input: Buffer.from(svgPath),
                      top: 0,
                      left: 0
                    }]).toBuffer().then(function (buffer) {
                      _this2.image.image = buffer;
                      resolve(buffer);
                    })["catch"](reject);
                  })["catch"](reject);
                }));

              case 2:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function renderText(_x3) {
        return _renderText.apply(this, arguments);
      }

      return renderText;
    }()
  }, {
    key: "drawLines",
    value: function () {
      var _drawLines = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
        var _this3 = this;

        var chunks, baseImage, imageMetadata, processedChunks;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this.lines.length) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return", true);

              case 2:
                chunks = (0, _lodash3["default"])(this.lines, LINE_RENDER_CHUNK_SIZE);
                baseImage = (0, _sharp["default"])(this.image.image);
                _context7.next = 6;
                return baseImage.metadata();

              case 6:
                imageMetadata = _context7.sent;
                processedChunks = chunks.map(function (c) {
                  return _this3.processChunk(c, imageMetadata);
                });
                _context7.next = 10;
                return baseImage.composite(processedChunks).toBuffer();

              case 10:
                this.image.image = _context7.sent;
                return _context7.abrupt("return", true);

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function drawLines() {
        return _drawLines.apply(this, arguments);
      }

      return drawLines;
    }()
  }, {
    key: "lineToSvg",
    value: function lineToSvg(line) {
      var _this4 = this;

      var points = line.coords.map(function (coord) {
        return [_this4.xToPx(lonToX(coord[0], _this4.zoom)), _this4.yToPx(latToY(coord[1], _this4.zoom))];
      });
      return "<".concat(line.type === 'polyline' ? 'polyline' : 'polygon', "\n                style=\"fill-rule: inherit;\"\n                points=\"").concat(points.join(' '), "\"\n                stroke=\"").concat(line.color, "\"\n                fill=\"").concat(line.fill ? line.fill : 'none', "\"\n                stroke-width=\"").concat(line.width, "\"/>");
    }
  }, {
    key: "processChunk",
    value: function processChunk(lines, imageMetadata) {
      var _this5 = this;

      var svgPath = "\n            <svg\n              width=\"".concat(imageMetadata.width, "px\"\n              height=\"").concat(imageMetadata.height, "\"\n              version=\"1.1\"\n              xmlns=\"http://www.w3.org/2000/svg\">\n              ").concat(lines.map(function (line) {
        return _this5.lineToSvg(line);
      }), "\n            </svg>");
      return {
        input: Buffer.from(svgPath),
        top: 0,
        left: 0
      };
    }
  }, {
    key: "drawMarker",
    value: function drawMarker() {
      var _this6 = this;

      var queue = [];
      this.markers.forEach(function (marker) {
        queue.push( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8() {
          var top, left;
          return _regenerator["default"].wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  top = Math.round(marker.position[1]);
                  left = Math.round(marker.position[0]);

                  if (!(top < 0 || left < 0 || top > _this6.height || left > _this6.width)) {
                    _context8.next = 4;
                    break;
                  }

                  return _context8.abrupt("return");

                case 4:
                  _context8.next = 6;
                  return (0, _sharp["default"])(_this6.image.image).composite([{
                    input: marker.imgData,
                    top: top,
                    left: left
                  }]).toBuffer();

                case 6:
                  _this6.image.image = _context8.sent;

                case 7:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8);
        })));
      });
      return (0, _asyncQueue["default"])(queue);
    }
    /**
      *   Preloading the icon image
      */

  }, {
    key: "loadMarker",
    value: function loadMarker() {
      var _this7 = this;

      return new Promise(function (resolve, reject) {
        if (!_this7.markers.length) resolve(true);
        var icons = (0, _lodash2["default"])(_this7.markers.map(function (m) {
          return {
            file: m.img
          };
        }), 'file');
        var count = 1;
        icons.forEach( /*#__PURE__*/function () {
          var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(ico) {
            var icon, isUrl, img;
            return _regenerator["default"].wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    icon = ico;
                    isUrl = !!_url["default"].parse(icon.file).hostname;
                    _context9.prev = 2;

                    if (!isUrl) {
                      _context9.next = 12;
                      break;
                    }

                    _context9.next = 6;
                    return _got["default"].get({
                      rejectUnauthorized: false,
                      url: icon.file,
                      responseType: 'buffer'
                    });

                  case 6:
                    img = _context9.sent;
                    _context9.next = 9;
                    return (0, _sharp["default"])(img).toBuffer();

                  case 9:
                    icon.data = _context9.sent;
                    _context9.next = 15;
                    break;

                  case 12:
                    _context9.next = 14;
                    return (0, _sharp["default"])(icon.file).toBuffer();

                  case 14:
                    icon.data = _context9.sent;

                  case 15:
                    _context9.next = 20;
                    break;

                  case 17:
                    _context9.prev = 17;
                    _context9.t0 = _context9["catch"](2);
                    reject(_context9.t0);

                  case 20:
                    if (count++ === icons.length) {
                      // Pre loaded all icons
                      _this7.markers.forEach(function (mark) {
                        var marker = mark;
                        marker.position = [_this7.xToPx(lonToX(marker.coord[0], _this7.zoom)) - marker.offset[0], _this7.yToPx(latToY(marker.coord[1], _this7.zoom)) - marker.offset[1]];
                        var imgData = (0, _lodash["default"])(icons, {
                          file: marker.img
                        });
                        marker.set(imgData.data);
                      });

                      resolve(true);
                    }

                  case 21:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9, null, [[2, 17]]);
          }));

          return function (_x4) {
            return _ref3.apply(this, arguments);
          };
        }());
      });
    }
    /**
     *  Fetching tile from endpoint
     */

  }, {
    key: "getTile",
    value: function getTile(data) {
      var _this8 = this;

      return new Promise(function (resolve) {
        var options = {
          url: data.url,
          responseType: 'buffer',
          resolveWithFullResponse: true,
          headers: _this8.tileRequestHeader || {},
          timeout: _this8.tileRequestTimeout
        }; // const defaultAgent = `staticmaps@${pjson.version}`;
        // options.headers['User-Agent'] = options.headers['User-Agent'] || defaultAgent;

        _got["default"].get(options).then(function (res) {
          resolve({
            success: true,
            tile: {
              url: data.url,
              box: data.box,
              body: res.body
            }
          });
        })["catch"](function (error) {
          return resolve({
            success: false,
            error: error
          });
        });
      });
    }
    /**
     *  Fetching tiles and limit concurrent connections
     */

  }, {
    key: "getTiles",
    value: function () {
      var _getTiles = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(baseLayers) {
        var _this9 = this;

        var limit, _ret, tilePromises;

        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                limit = this.tileRequestLimit; // Limit concurrent connections to tiles server
                // https://operations.osmfoundation.org/policies/tiles/#technical-usage-requirements

                if (!Number(limit)) {
                  _context13.next = 6;
                  break;
                }

                return _context13.delegateYield( /*#__PURE__*/_regenerator["default"].mark(function _callee12() {
                  var aQueue, tiles, _loop, i, j;

                  return _regenerator["default"].wrap(function _callee12$(_context12) {
                    while (1) {
                      switch (_context12.prev = _context12.next) {
                        case 0:
                          aQueue = [];
                          tiles = [];

                          _loop = function _loop(i, j) {
                            var chunks = baseLayers.slice(i, i + limit);
                            var sQueue = [];
                            aQueue.push( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11() {
                              return _regenerator["default"].wrap(function _callee11$(_context11) {
                                while (1) {
                                  switch (_context11.prev = _context11.next) {
                                    case 0:
                                      chunks.forEach(function (r) {
                                        sQueue.push((0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10() {
                                          var tile;
                                          return _regenerator["default"].wrap(function _callee10$(_context10) {
                                            while (1) {
                                              switch (_context10.prev = _context10.next) {
                                                case 0:
                                                  _context10.next = 2;
                                                  return _this9.getTile(r);

                                                case 2:
                                                  tile = _context10.sent;
                                                  tiles.push(tile);

                                                case 4:
                                                case "end":
                                                  return _context10.stop();
                                              }
                                            }
                                          }, _callee10);
                                        }))());
                                      });
                                      _context11.next = 3;
                                      return Promise.all(sQueue);

                                    case 3:
                                    case "end":
                                      return _context11.stop();
                                  }
                                }
                              }, _callee11);
                            })));
                          };

                          for (i = 0, j = baseLayers.length; i < j; i += limit) {
                            _loop(i, j);
                          }

                          _context12.next = 6;
                          return (0, _asyncQueue["default"])(aQueue);

                        case 6:
                          return _context12.abrupt("return", {
                            v: tiles
                          });

                        case 7:
                        case "end":
                          return _context12.stop();
                      }
                    }
                  }, _callee12);
                })(), "t0", 3);

              case 3:
                _ret = _context13.t0;

                if (!((0, _typeof2["default"])(_ret) === "object")) {
                  _context13.next = 6;
                  break;
                }

                return _context13.abrupt("return", _ret.v);

              case 6:
                // Do not limit concurrent connections at all
                tilePromises = [];
                baseLayers.forEach(function (r) {
                  tilePromises.push(_this9.getTile(r));
                });
                return _context13.abrupt("return", Promise.all(tilePromises));

              case 9:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getTiles(_x5) {
        return _getTiles.apply(this, arguments);
      }

      return getTiles;
    }()
  }]);
  return StaticMaps;
}();

var _default = StaticMaps;
exports["default"] = _default;
module.exports = StaticMaps;